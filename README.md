## Практическая работа №15. Вуйко Ярослава, ЭФМО-01-25

Оптимизация запросов к БД. Использование connection pool. 18.12.2025

## Цели работы
1. Освоить интеграционное тестирование REST API: проверка «маршрут → хендлер → сервис → репозиторий → реальная БД».
2. Научиться поднимать изолированную тестовую среду БД в Docker.
3. Освоить 2 подхода к инфраструктуре тестов
4. Научиться инициализировать схему БД (миграции/auto-migrate), сидировать тестовые данные, очищать окружение.
5. Внедрить интеграционные проверки CRUD-эндпоинтов (статусы, заголовки, JSON-ответы, эффекты в БД).



## Структура проекта

```
.
├── cmd/
│   └── api/
│       └── main.go
├── integretion/
│   ├── notes_integration_test.go
│   ├── swagger.json
│   └── swagger.yaml
├── internal/
│   ├── db/
│   │   └── migrate.go
│   ├── httpapi/
│   │   └── handlers.go
│   ├── models/
│   │   └── note.go
│   ├── repo/
│   │   └── note.go
│   └── service/
│       └── service.go
├── docker-compose.yml
├── go.mod
├── go.sum
├── Makefile
└── README.md
```



### Запуск всех тестов
go test ./...

### Подробный вывод
go test -v ./internal/...
<img width="592" height="903" alt="2025-12-18_15-30-49" src="https://github.com/user-attachments/assets/2493c721-6405-4904-a32f-331ab3212320" />

### Проверка покрытия
go test -cover ./...
<img width="885" height="88" alt="2025-12-18_15-31-02" src="https://github.com/user-attachments/assets/e202eb56-f8d3-4cbe-b80a-8745c0ac3560" />

### Генерация профиля покрытия
go test -coverprofile=coverage.out ./...

### Открытие html-отчёта по покрытию
go tool cover -html=coverage.out
<img width="923" height="189" alt="2025-12-18_15-35-52" src="https://github.com/user-attachments/assets/c43f4bda-5cfc-496a-9a92-ae061bfb2cee" />


### Html-отчёта по покрытию
<img width="680" height="344" alt="image" src="https://github.com/user-attachments/assets/4302c1be-103b-4295-9a1c-66f2219fe957" />


### Запуск бенчмарков
<img width="587" height="181" alt="image" src="https://github.com/user-attachments/assets/0c7fceb4-ae41-4251-b749-5b6ed689292c" />


### Краткие выводы
- Протестированы все основные функции проекта: Sum, Divide, Clip и метод FindIDByEmail сервиса.
- Табличные тесты (t.Run) и проверка граничных случаев позволили убедиться в корректной обработке отрицательных и нулевых значений, пустых строк, ошибок деления.
- Для сервиса использован stub (stubRepo), что позволило изолировать бизнес-логику от базы данных — это именно unit-тест.
- Дополнительно проверена обработка ошибок, паник и реализован простой бенчмарк для функции Sum.
- Покрытие тестами всех пакетов составляет 100%, что подтверждает тестирование всех ветвлений и ошибок.


### Требования
- Go 1.21 или выше


## Ответы на контрольные вопросы:
1. Чем unit-тест отличается от интеграционного и почему важна изоляция зависимостей?
Unit-тест проверяет отдельную функцию или метод в изоляции, тогда как интеграционный тест проверяет взаимодействие нескольких компонентов.
2. Как устроены табличные тесты в Go и когда они особенно полезны?
Табличные тесты (table-driven tests) используют срез структур с набором входных данных и ожидаемым результатом, через цикл прогоняются все кейсы. Они особенно полезны для проверки одинаковой функции на множестве значений, включая граничные случаи.
3. В чём преимущества testify по сравнению с «чистым» testing, и когда достаточно стандартного пакета?
Testify предоставляет удобные утверждения для проверки равенства, ошибок и паник, делая тесты более читаемыми и компактными. Стандартного пакета testing достаточно для простых проверок и там, где не нужны дополнительные удобства или компактный синтаксис.
4. Что проверяет go test -cover и почему высокий процент покрытия не гарантирует качество тестов?
go test -cover показывает, какой процент строк кода был выполнен тестами. Высокое покрытие не гарантирует качество, так как тесты могут просто запускать код без проверки корректности результатов и обработки ошибок.
5. Как тестировать функции, которые возвращают ошибки? Примеры хороших негативных кейсов.
Нужно проверять как успешные сценарии, так и сценарии с ошибкой. Хорошие негативные кейсы — это случаи, когда функция должна вернуть ошибку.
6. Как использовать интерфейсы и стабы/моки, чтобы тестировать бизнес-логику без БД?
Создают интерфейс для внешней зависимости и подставляют stub или mock, который возвращает заранее известные данные или проверяет вызовы методов.




